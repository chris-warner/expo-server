{
  "version": 3,
  "sources": ["../src/consts.ts", "../src/generated-processor.ts", "../src/utils.ts", "../src/analyzer.ts", "../src/realtime-bpm-analyzer.ts", "../src/index.ts"],
  "sourcesContent": ["export const realtimeBpmProcessorName = 'realtime-bpm-processor';\nexport const startThreshold = 0.95;\nexport const minValidThreshold = 0.2;\nexport const minPeaks = 15;\nexport const thresholdStep = 0.05;\nexport const skipForwardIndexes = 10000;\nexport const offlineLowPassFrequencyValue = 150;\nexport const offlineLowPassQualityValue = 1;\nexport const offlineHighPassFrequencyValue = 100;\nexport const offlineHighPassQualityValue = 1;\n\n", "export default `\"use strict\";(()=>{var x=\"realtime-bpm-processor\";async function p(n,o=.2,e=.95,s=.05){let t=e;do if(t-=s,await n(t))break;while(t>o)}function y(n=.2,o=.95,e=.05){let s={},t=o;do t-=e,s[t.toString()]=[];while(t>n);return s}function A(n=.2,o=.95,e=.05){let s={},t=o;do t-=e,s[t.toString()]=0;while(t>n);return s}function h(){let o=0,e=new Float32Array(0);function s(){o=0,e=new Float32Array(0)}function t(){return o===4096}function a(){s()}return function(r){t()&&a();let l=new Float32Array(e.length+r.length);return l.set(e,0),l.set(r,e.length),e=l,o+=r.length,{isBufferFull:t(),buffer:e,bufferSize:4096}}}function v(n,o,e=0,s=1e4){let t=[],{length:a}=n;for(let r=e;r<a;r+=1)n[r]>o&&(t.push(r),r+=s);return{peaks:t,threshold:o}}async function b(n,o){let e=15,s=!1,t=.2;if(await p(async a=>s?!0:(n[a].length>e&&(s=!0,t=a),!1)),s&&t){let a=w(n[t]),r=C(o,a);return{bpm:V(r),threshold:t}}return{bpm:[],threshold:t}}function V(n,o=5){return n.sort((e,s)=>s.count-e.count).splice(0,o)}function w(n){let o=[];for(let e=0;e<n.length;e++)for(let s=0;s<10;s++){let t=n[e],a=e+s,r=n[a]-t;if(!o.some(i=>i.interval===r?(i.count+=1,i.count):!1)){let i={interval:r,count:1};o.push(i)}}return o}function C(n,o){let e=[];for(let s of o){if(s.interval===0)continue;s.interval=Math.abs(s.interval);let t=60/(s.interval/n);for(;t<90;)t*=2;for(;t>180;)t/=2;if(t=Math.round(t),!e.some(r=>r.tempo===t?(r.count+=s.count,r.count):!1)){let r={tempo:t,count:s.count,confidence:0};e.push(r)}}return e}var d={minValidThreshold:()=>.2,validPeaks:()=>y(),nextIndexPeaks:()=>A(),skipIndexes:()=>1,effectiveBufferTime:()=>0},m=class{constructor(){this.options={continuousAnalysis:!1,stabilizationTime:2e4,muteTimeInIndexes:1e4,debug:!1};this.minValidThreshold=d.minValidThreshold();this.validPeaks=d.validPeaks();this.nextIndexPeaks=d.nextIndexPeaks();this.skipIndexes=d.skipIndexes();this.effectiveBufferTime=d.effectiveBufferTime();this.computedStabilizationTimeInSeconds=0;this.updateComputedValues()}setAsyncConfiguration(o){Object.assign(this.options,o),this.updateComputedValues()}updateComputedValues(){this.computedStabilizationTimeInSeconds=this.options.stabilizationTime/1e3}reset(){this.minValidThreshold=d.minValidThreshold(),this.validPeaks=d.validPeaks(),this.nextIndexPeaks=d.nextIndexPeaks(),this.skipIndexes=d.skipIndexes(),this.effectiveBufferTime=d.effectiveBufferTime()}async clearValidPeaks(o){this.minValidThreshold=Number.parseFloat(o.toFixed(2)),await p(async e=>(e<o&&this.validPeaks[e]!==void 0&&(delete this.validPeaks[e],delete this.nextIndexPeaks[e]),!1))}async analyzeChunck(o,e,s,t){this.options.debug&&t({message:\"ANALYZE_CHUNK\",data:o}),this.effectiveBufferTime+=s;let a=s*this.skipIndexes,r=a-s;await this.findPeaks(o,s,r,a,t),this.skipIndexes++;let l=await b(this.validPeaks,e),{threshold:i}=l;t({message:\"BPM\",result:l}),this.minValidThreshold<i&&(t({message:\"BPM_STABLE\",result:l}),await this.clearValidPeaks(i)),this.options.continuousAnalysis&&this.effectiveBufferTime/e>this.computedStabilizationTimeInSeconds&&(this.reset(),t({message:\"ANALYZER_RESETED\"}))}async findPeaks(o,e,s,t,a){await p(async r=>{if(this.nextIndexPeaks[r]>=t)return!1;let l=this.nextIndexPeaks[r]%e,{peaks:i,threshold:c}=v(o,r,l);if(i.length===0)return!1;for(let I of i){let f=s+I;this.nextIndexPeaks[c]=f+this.options.muteTimeInIndexes,this.validPeaks[c].push(f),this.options.debug&&a({message:\"VALID_PEAK\",data:{threshold:c,index:f}})}return!1},this.minValidThreshold)}};var T=class extends AudioWorkletProcessor{constructor(){super();this.realTimeBpmAnalyzer=new m;this.stopped=!1;this.aggregate=h(),this.port.addEventListener(\"message\",this.onMessage.bind(this)),this.port.start()}onMessage(e){e.data.message===\"ASYNC_CONFIGURATION\"&&(console.log(\"[processor.onMessage] ASYNC_CONFIGURATION\"),this.realTimeBpmAnalyzer.setAsyncConfiguration(e.data.parameters)),e.data.message===\"RESET\"&&(console.log(\"[processor.onMessage] RESET\"),this.aggregate=h(),this.stopped=!1,this.realTimeBpmAnalyzer.reset()),e.data.message===\"STOP\"&&(console.log(\"[processor.onMessage] STOP\"),this.aggregate=h(),this.stopped=!0,this.realTimeBpmAnalyzer.reset())}process(e,s,t){let a=e[0][0];if(this.stopped||!a)return!0;let{isBufferFull:r,buffer:l,bufferSize:i}=this.aggregate(a);return r&&this.realTimeBpmAnalyzer.analyzeChunck(l,sampleRate,i,c=>{this.port.postMessage(c)}).catch(c=>{console.error(c)}),!0}};registerProcessor(x,T);var Q={};})();\n//# sourceMappingURL=realtime-bpm-processor.js.map\n`;", "import * as consts from './consts';\nimport type {Peaks, ValidPeaks, NextIndexPeaks, OnThresholdFunction, AggregateData} from './types';\n\n/**\n * Loop between .9 and minValidThreshold at .2 by default, passing the threshold to the function\n * @param {OnThresholdFunction} onThreshold Function for each iteration, you must return a boolean, true will exit the loop process\n * @param {number} minValidThreshold minValidThreshold usualy 0.2\n * @param {number} startThreshold startThreshold usualy 0.9\n * @param {number} thresholdStep thresholdStep usuably 0.05\n * @return {Promise<void>}\n */\nexport async function descendingOverThresholds(onThreshold: OnThresholdFunction, minValidThreshold = consts.minValidThreshold, startThreshold = consts.startThreshold, thresholdStep = consts.thresholdStep): Promise<void> {\n  let threshold = startThreshold;\n\n  do {\n    threshold -= thresholdStep;\n    const shouldExit = await onThreshold(threshold);\n    if (shouldExit) {\n      break;\n    }\n  } while (threshold > minValidThreshold);\n}\n\n/**\n * Generate an object with keys as thresholds and will containes validPeaks\n * @param {number} minValidThreshold minValidThreshold usualy 0.2\n * @param {number} startThreshold startThreshold usualy 0.9\n * @param {number} thresholdStep thresholdStep usuably 0.05\n * @return {ValidPeaks} Collection of validPeaks by thresholds\n */\nexport function generateValidPeaksModel(minValidThreshold = consts.minValidThreshold, startThreshold = consts.startThreshold, thresholdStep = consts.thresholdStep): ValidPeaks {\n  const object: Record<string, Peaks> = {};\n  let threshold = startThreshold;\n\n  do {\n    threshold -= thresholdStep;\n    object[threshold.toString()] = [];\n  } while (threshold > minValidThreshold);\n\n  return object;\n}\n\n/**\n * Generate an object with keys as thresholds and will containes NextIndexPeaks\n * @return {NextIndexPeaks} Collection of NextIndexPeaks by thresholds\n */\nexport function generateNextIndexPeaksModel(minValidThreshold = consts.minValidThreshold, startThreshold = consts.startThreshold, thresholdStep = consts.thresholdStep): NextIndexPeaks {\n  const object: Record<string, number> = {};\n  let threshold = startThreshold;\n\n  do {\n    threshold -= thresholdStep;\n    object[threshold.toString()] = 0;\n  } while (threshold > minValidThreshold);\n\n  return object;\n}\n\nexport function chunckAggregator(): (pcmData: Float32Array) => AggregateData {\n  const bufferSize = 4096;\n\n  /**\n   * Track the current buffer fill level\n   */\n  let _bytesWritten = 0;\n\n  /**\n   * Create a buffer of fixed size\n   */\n  let buffer: Float32Array = new Float32Array(0);\n\n  function initBuffer(): void {\n    _bytesWritten = 0;\n    buffer = new Float32Array(0);\n  }\n\n  function isBufferFull(): boolean {\n    return _bytesWritten === bufferSize;\n  }\n\n  function flush(): void {\n    initBuffer();\n  }\n\n  return function (pcmData: Float32Array): AggregateData {\n    if (isBufferFull()) {\n      flush();\n    }\n\n    const newBuffer = new Float32Array(buffer.length + pcmData.length);\n    newBuffer.set(buffer, 0);\n    newBuffer.set(pcmData, buffer.length);\n    buffer = newBuffer;\n    _bytesWritten += pcmData.length;\n\n    return {\n      isBufferFull: isBufferFull(),\n      buffer,\n      bufferSize,\n    };\n  };\n}\n", "import {descendingOverThresholds} from './utils';\nimport type {\n  Peaks,\n  ValidPeaks,\n  PeaksAndThreshold,\n  BpmCandidates,\n  Interval,\n  Tempo,\n  Threshold,\n  NormalizedFilters,\n} from './types';\nimport * as consts from './consts';\n\n/**\n * Find peaks when the signal if greater than the threshold, then move 10_000 indexes (represents ~0.23s) to ignore the descending phase of the parabol\n * @param {Float32Array} data Buffer channel data\n * @param {number} threshold Threshold for qualifying as a peak\n * @param {number} offset Position where we start to loop\n * @param {number} skipForwardIndexes Numbers of index to skip when a peak is detected\n * @return {PeaksAndThreshold} Peaks found that are greater than the threshold\n */\nexport function findPeaksAtThreshold(data: Float32Array, threshold: Threshold, offset = 0, skipForwardIndexes = consts.skipForwardIndexes): PeaksAndThreshold {\n  const peaks: Peaks = [];\n\n  const {length} = data;\n\n  /**\n   * Identify peaks that are greater than the threshold, adding them to the collection\n   */\n  for (let i = offset; i < length; i += 1) {\n    if (data[i] > threshold) {\n      peaks.push(i);\n\n      /**\n       * Skip forward ~0.25s to pass this peak\n       */\n      i += skipForwardIndexes;\n    }\n  }\n\n  return {\n    peaks,\n    threshold,\n  };\n}\n\n/**\n * Find the minimum amount of peaks from top to bottom threshold, it's necessary to analyze at least 10seconds at 90bpm\n * @param {Float32Array} channelData Channel data\n * @returns {Promise<PeaksAndThreshold>} Suffisent amount of peaks in order to continue further the process\n */\nexport async function findPeaks(channelData: Float32Array): Promise<PeaksAndThreshold> {\n  let validPeaks: Peaks = [];\n  let validThreshold = 0;\n\n  await descendingOverThresholds(async threshold => {\n    const {peaks} = findPeaksAtThreshold(channelData, threshold);\n\n    /**\n     * Loop over peaks\n     */\n    if (peaks.length < consts.minPeaks) {\n      return false;\n    }\n\n    validPeaks = peaks;\n    validThreshold = threshold;\n\n    return true;\n  });\n\n  return {\n    peaks: validPeaks,\n    threshold: validThreshold,\n  };\n}\n\n/**\n * Helpfull function to create standard and shared lowpass and highpass filters\n * Important Note: The original library wasn't using properly the lowpass filter and it was not applied at all. This method should not be used unitl more research and documented tests will be acheived.\n * @param {AudioContext | OfflineAudioContext} context AudioContext instance\n * @returns {NormalizedFilters} Normalized biquad filters\n */\nexport function getBiquadFilters(context: AudioContext | OfflineAudioContext): NormalizedFilters {\n  const lowpass = context.createBiquadFilter();\n  lowpass.type = 'lowpass';\n  lowpass.frequency.value = consts.offlineLowPassFrequencyValue;\n  lowpass.Q.value = consts.offlineLowPassQualityValue;\n\n  const highpass = context.createBiquadFilter();\n  highpass.type = 'highpass';\n  highpass.frequency.value = consts.offlineHighPassFrequencyValue;\n  highpass.Q.value = consts.offlineHighPassQualityValue;\n\n  return {\n    lowpass,\n    highpass,\n  };\n}\n\n/**\n * Apply to the source a biquad lowpass filter\n * @param {AudioBuffer} buffer Audio buffer\n * @returns {AudioBufferSourceNode}\n */\n// export async function getOfflineLowPassSource(buffer: AudioBuffer): Promise<AudioBuffer> {\n//   const {length, numberOfChannels, sampleRate} = buffer;\n//   const context = new OfflineAudioContext(numberOfChannels, length, sampleRate);\n\n//   /**\n//    * Create buffer source\n//    */\n//   const source = context.createBufferSource();\n//   source.buffer = buffer;\n\n//   const {lowpass, highpass} = getBiquadFilters(context);\n\n//   /**\n//    * Pipe the song into the filter, and the filter into the offline context\n//    */\n//   source.connect(lowpass);\n//   source.connect(highpass);\n//   lowpass.connect(highpass);\n//   highpass.connect(context.destination);\n\n//   source.start(0);\n\n//   const audioBuffer = await context.startRendering();\n\n//   return audioBuffer;\n// }\n\n/**\n * Return the computed bpm from data\n * @param {Record<string, number[]>} data Contain valid peaks\n * @param {number} audioSampleRate Audio sample rate\n */\nexport async function computeBpm(data: ValidPeaks, audioSampleRate: number): Promise<BpmCandidates> {\n  const minPeaks = consts.minPeaks;\n\n  /**\n   * Flag to fix Object.keys looping\n   */\n  let hasPeaks = false;\n  let foundThreshold = consts.minValidThreshold;\n\n  await descendingOverThresholds(async (threshold: Threshold) => {\n    if (hasPeaks) {\n      return true;\n    }\n\n    if (data[threshold].length > minPeaks) {\n      hasPeaks = true;\n      foundThreshold = threshold;\n    }\n\n    return false;\n  });\n\n  if (hasPeaks && foundThreshold) {\n    const intervals = identifyIntervals(data[foundThreshold]);\n    const tempos = groupByTempo(audioSampleRate, intervals);\n    const candidates = getTopCandidates(tempos);\n\n    const bpmCandidates: BpmCandidates = {\n      bpm: candidates,\n      threshold: foundThreshold,\n    };\n\n    return bpmCandidates;\n  }\n\n  return {\n    bpm: [],\n    threshold: foundThreshold,\n  };\n}\n\n/**\n * Sort results by count and return top candidate\n * @param {Tempo[]} candidates (BPMs) with count\n * @param {number} length Amount of returned candidates (default: 5)\n * @return {Tempo[]} Returns the 5 top candidates with highest counts\n */\nexport function getTopCandidates(candidates: Tempo[], length = 5): Tempo[] {\n  return candidates.sort((a, b) => (b.count - a.count)).splice(0, length);\n}\n\n/**\n * Gets the top candidate from the array\n * @param {Tempo[]} candidates - (BPMs) with counts.\n * @returns {number} - Returns the top candidate with the highest count.\n */\nexport function getTopCandidate(candidates: Tempo[]): number {\n  if (candidates.length === 0) {\n    throw new Error('Could not find enough samples for a reliable detection.');\n  }\n\n  const [first] = candidates.sort((a, b) => (b.count - a.count));\n\n  return first.tempo;\n}\n\n/**\n * Identify intervals between bass peaks\n * @param {array} peaks Array of qualified bass peaks\n * @return {array} Return a collection of intervals between peaks\n */\nexport function identifyIntervals(peaks: Peaks): Interval[] {\n  const intervals: Interval[] = [];\n\n  for (let n = 0; n < peaks.length; n++) {\n    for (let i = 0; i < 10; i++) {\n      const peak = peaks[n];\n      const peakIndex = n + i;\n      const interval = peaks[peakIndex] - peak;\n\n      /**\n       * Try and find a matching interval and increase it's count\n       */\n      const foundInterval = intervals.some((intervalCount: Interval) => {\n        if (intervalCount.interval === interval) {\n          intervalCount.count += 1;\n          return intervalCount.count;\n        }\n\n        return false;\n      });\n\n      /**\n       * Add the interval to the collection if it's unique\n       */\n      if (!foundInterval) {\n        const item: Interval = {\n          interval,\n          count: 1,\n        };\n        intervals.push(item);\n      }\n    }\n  }\n\n  return intervals;\n}\n\n/**\n * Figure out best possible tempo candidates\n * @param  {number} audioSampleRate Audio sample rate\n * @param  {Interval[]} intervalCounts List of identified intervals\n * @return {Tempo[]} Intervals grouped with similar values\n */\nexport function groupByTempo(audioSampleRate: number, intervalCounts: Interval[]): Tempo[] {\n  const tempoCounts: Tempo[] = [];\n\n  for (const intervalCount of intervalCounts) {\n    /**\n     * Skip if interval is equal 0\n     */\n    if (intervalCount.interval === 0) {\n      continue;\n    }\n\n    intervalCount.interval = Math.abs(intervalCount.interval);\n\n    /**\n     * Convert an interval to tempo\n     */\n    let theoreticalTempo = (60 / (intervalCount.interval / audioSampleRate));\n\n    /**\n     * Adjust the tempo to fit within the 90-180 BPM range\n     */\n    while (theoreticalTempo < 90) {\n      theoreticalTempo *= 2;\n    }\n\n    while (theoreticalTempo > 180) {\n      theoreticalTempo /= 2;\n    }\n\n    /**\n     * Round to legible integer\n     */\n    theoreticalTempo = Math.round(theoreticalTempo);\n\n    /**\n     * See if another interval resolved to the same tempo\n     */\n    const foundTempo: boolean = tempoCounts.some((tempoCount: Tempo) => {\n      if (tempoCount.tempo === theoreticalTempo) {\n        tempoCount.count += intervalCount.count;\n        return tempoCount.count;\n      }\n\n      return false;\n    });\n\n    /**\n     * Add a unique tempo to the collection\n     */\n    if (!foundTempo) {\n      const tempo: Tempo = {\n        tempo: theoreticalTempo,\n        count: intervalCount.count,\n        confidence: 0,\n      };\n\n      tempoCounts.push(tempo);\n    }\n  }\n\n  return tempoCounts;\n}\n\n/**\n * Function to detect the BPM from an AudioBuffer (which can be a whole file)\n * It is the fastest way to detect the BPM\n * @param {AudioBuffer} buffer AudioBuffer\n * @returns {Promise<Tempo[]>} Returns the 5 bests candidates\n */\nexport async function analyzeFullBuffer(buffer: AudioBuffer): Promise<Tempo[]> {\n  const channelData = buffer.getChannelData(0);\n\n  const {peaks} = await findPeaks(channelData);\n  const intervals = identifyIntervals(peaks);\n  const tempos = groupByTempo(buffer.sampleRate, intervals);\n  const topCandidates = getTopCandidates(tempos, channelData.length);\n\n  return topCandidates;\n}\n", "import {findPeaksAtThreshold, computeBpm} from './analyzer';\nimport type {\n  RealTimeBpmAnalyzerOptions,\n  RealTimeBpmAnalyzerParameters,\n  ValidPeaks,\n  NextIndexPeaks,\n  BpmCandidates,\n  Threshold,\n  PostMessageEventData,\n} from './types';\nimport {\n  generateValidPeaksModel,\n  generateNextIndexPeaksModel,\n  descendingOverThresholds,\n} from './utils';\nimport * as consts from './consts';\n\n/**\n * Initial value of key parameters of the analyzer\n */\nconst initialValue = {\n  minValidThreshold: () => consts.minValidThreshold,\n  validPeaks: () => generateValidPeaksModel(),\n  nextIndexPeaks: () => generateNextIndexPeaksModel(),\n  skipIndexes: () => 1,\n  effectiveBufferTime: () => 0,\n};\n\n/**\n * @class RealTimeBpmAnalyzer\n **/\nexport class RealTimeBpmAnalyzer {\n  /**\n   * Default configuration\n   */\n  options: RealTimeBpmAnalyzerOptions = {\n    continuousAnalysis: false,\n    stabilizationTime: 20000,\n    muteTimeInIndexes: 10000,\n    debug: false,\n  };\n\n  /**\n   * Minimum valid threshold, below this level result would be irrelevant.\n   */\n  minValidThreshold: Threshold = initialValue.minValidThreshold();\n  /**\n   * Contain all valid peaks\n   */\n  validPeaks: ValidPeaks = initialValue.validPeaks();\n  /**\n   * Next index (+10000 ...) to take care about peaks\n   */\n  nextIndexPeaks: NextIndexPeaks = initialValue.nextIndexPeaks();\n  /**\n   * Number / Position of chunks\n   */\n  skipIndexes: number = initialValue.skipIndexes();\n  effectiveBufferTime: number = initialValue.effectiveBufferTime();\n  /**\n   * Computed values\n   */\n  computedStabilizationTimeInSeconds = 0;\n\n  /**\n   * @constructor\n   */\n  constructor() {\n    this.updateComputedValues();\n  }\n\n  /**\n   * Method to apply a configuration on the fly\n   * @param {RealTimeBpmAnalyzerParameters} parameters Object containing optional parameters\n   * @returns {void}\n   */\n  setAsyncConfiguration(parameters: RealTimeBpmAnalyzerParameters): void {\n    Object.assign(this.options, parameters);\n    this.updateComputedValues();\n  }\n\n  /**\n   * Update the computed values\n   * @returns {void}\n   */\n  updateComputedValues() {\n    this.computedStabilizationTimeInSeconds = this.options.stabilizationTime / 1000;\n  }\n\n  /**\n   * Reset BPM computation properties to get a fresh start\n   * @returns {void}\n   */\n  reset(): void {\n    this.minValidThreshold = initialValue.minValidThreshold();\n    this.validPeaks = initialValue.validPeaks();\n    this.nextIndexPeaks = initialValue.nextIndexPeaks();\n    this.skipIndexes = initialValue.skipIndexes();\n    this.effectiveBufferTime = initialValue.effectiveBufferTime();\n  }\n\n  /**\n   * Remve all validPeaks between the minThreshold pass in param to optimize the weight of datas\n   * @param {Threshold} minThreshold Value between 0.9 and 0.2\n   * @returns {void}\n   */\n  async clearValidPeaks(minThreshold: Threshold): Promise<void> {\n    this.minValidThreshold = Number.parseFloat(minThreshold.toFixed(2));\n\n    await descendingOverThresholds(async threshold => {\n      if (threshold < minThreshold && this.validPeaks[threshold] !== undefined) {\n        delete this.validPeaks[threshold]; // eslint-disable-line @typescript-eslint/no-dynamic-delete\n        delete this.nextIndexPeaks[threshold]; // eslint-disable-line @typescript-eslint/no-dynamic-delete\n      }\n\n      return false;\n    });\n  }\n\n  /**\n   * Attach this function to an audioprocess event on a audio/video node to compute BPM / Tempo in realtime\n   * @param {Float32Array} channelData Channel data\n   * @param {number} audioSampleRate Audio sample rate (44100)\n   * @param {number} bufferSize Buffer size (4096)\n   * @param {(data: PostMessageEventData) => void} postMessage Function to post a message to the processor node\n   * @returns {Promise<void>}\n   */\n  async analyzeChunck(channelData: Float32Array, audioSampleRate: number, bufferSize: number, postMessage: (data: PostMessageEventData) => void): Promise<void> {\n    if (this.options.debug) {\n      postMessage({message: 'ANALYZE_CHUNK', data: channelData});\n    }\n\n    /**\n     * We are summing up the size of each analyzed chunks in order to compute later if we reached the stabilizationTime\n     * Ex: effectiveBufferTime / audioSampleRate = timeInSeconds (1000000/44100=22s)\n     */\n    this.effectiveBufferTime += bufferSize;\n\n    /**\n     * Compute the maximum index with all previous chunks\n     */\n    const currentMaxIndex = bufferSize * this.skipIndexes;\n\n    /**\n     * Compute the minimum index with all previous chunks\n     */\n    const currentMinIndex = currentMaxIndex - bufferSize;\n\n    /**\n     * Mutate nextIndexPeaks and validPeaks if possible\n     */\n    await this.findPeaks(channelData, bufferSize, currentMinIndex, currentMaxIndex, postMessage);\n\n    /**\n     * Increment chunk\n     */\n    this.skipIndexes++;\n\n    const result: BpmCandidates = await computeBpm(this.validPeaks, audioSampleRate);\n    const {threshold} = result;\n    postMessage({message: 'BPM', result});\n\n    /**\n     * If the results found have a \"high\" threshold, the BPM is considered stable/strong\n     */\n    if (this.minValidThreshold < threshold) {\n      postMessage({message: 'BPM_STABLE', result});\n      await this.clearValidPeaks(threshold);\n    }\n\n    /**\n     * After x time, we reinit the analyzer\n     */\n    if (this.options.continuousAnalysis && this.effectiveBufferTime / audioSampleRate > this.computedStabilizationTimeInSeconds) {\n      this.reset();\n      postMessage({message: 'ANALYZER_RESETED'});\n    }\n  }\n\n  /**\n   * Find the best threshold with enought peaks\n   * @param {Float32Array} channelData Channel data\n   * @param {number} bufferSize Buffer size\n   * @param {number} currentMinIndex Current minimum index\n   * @param {number} currentMaxIndex Current maximum index\n   * @param {(data: PostMessageEventData) => void} postMessage Function to post a message to the processor node\n   * @returns {void}\n   */\n  async findPeaks(channelData: Float32Array, bufferSize: number, currentMinIndex: number, currentMaxIndex: number, postMessage: (data: PostMessageEventData) => void): Promise<void> {\n    await descendingOverThresholds(async threshold => {\n      if (this.nextIndexPeaks[threshold] >= currentMaxIndex) {\n        return false;\n      }\n\n      /**\n       * Get the next index in the next chunk\n       */\n      const offsetForNextPeak = this.nextIndexPeaks[threshold] % bufferSize; // 0 - 4095\n\n      const {peaks, threshold: atThreshold} = findPeaksAtThreshold(channelData, threshold, offsetForNextPeak);\n\n      /**\n       * Loop over peaks\n       */\n      if (peaks.length === 0) {\n        return false;\n      }\n\n      for (const relativeChunkPeak of peaks) {\n        const index = currentMinIndex + relativeChunkPeak;\n\n        /**\n         * Add current Index + muteTimeInIndexes (10000/44100=0.22s)\n         */\n        this.nextIndexPeaks[atThreshold] = index + this.options.muteTimeInIndexes;\n\n        /**\n         * Store valid relativeChunkPeak Indexes\n         */\n        this.validPeaks[atThreshold].push(index);\n\n        if (this.options.debug) {\n          postMessage({\n            message: 'VALID_PEAK',\n            data: {\n              threshold: atThreshold,\n              index,\n            },\n          });\n        }\n      }\n\n      return false;\n    }, this.minValidThreshold);\n  }\n}\n", "import {realtimeBpmProcessorName} from './consts';\nimport realtimeBpmProcessorContent from './generated-processor';\n\nexport * from './realtime-bpm-analyzer';\nexport {analyzeFullBuffer, getBiquadFilters} from './analyzer';\nexport * from './types';\n\n/**\n * Create the RealTimeBpmProcessor needed to run the realtime strategy\n * @param {AudioContext} audioContext AudioContext instance\n * @returns {Promise<AudioWorkletNode>}\n * @public\n */\nexport async function createRealTimeBpmProcessor(audioContext: AudioContext): Promise<AudioWorkletNode> {\n  const processorNode = await setupAudioWorkletNode(audioContext, realtimeBpmProcessorName);\n\n  await audioContext.resume();\n\n  return processorNode;\n}\n\n/**\n * Creates AudioWorkletNode for the Processor\n * @param {AudioContext} audioContext AudioContext instance\n * @param {string} processorName Name of the audio processor, without the extension\n * @return {Promise<AudioWorkletNode>} Recording node related components for the app.\n * @private\n */\nasync function setupAudioWorkletNode(audioContext: AudioContext, processorName: string): Promise<AudioWorkletNode> {\n  const blob = new Blob([realtimeBpmProcessorContent], {type: 'application/javascript'});\n\n  const objectUrl = URL.createObjectURL(blob);\n\n  await audioContext.audioWorklet.addModule(objectUrl);\n\n  const audioWorkletNode = new AudioWorkletNode(audioContext, processorName);\n\n  return audioWorkletNode;\n}\n"],
  "mappings": "mBAAO,IAAMA,EAA2B,yBCAxC,IAAOC,EAAQ;AAAA;ECWf,eAAsBC,EAAyBC,EAAkCC,EAA2B,GAAmBC,EAAwB,IAAgBC,EAAuB,IAA8B,CAC1N,IAAIC,EAAYF,EAEhB,EAGE,IAFAE,GAAaD,EACM,MAAMH,EAAYI,CAAS,EAE5C,YAEKA,EAAYH,EACvB,CASO,SAASI,EAAwBJ,EAA2B,GAAmBC,EAAwB,IAAgBC,EAAuB,IAA2B,CAC9K,IAAMG,EAAgC,CAAC,EACnCF,EAAYF,EAEhB,GACEE,GAAaD,EACbG,EAAOF,EAAU,SAAS,CAAC,EAAI,CAAC,QACzBA,EAAYH,GAErB,OAAOK,CACT,CAMO,SAASC,EAA4BN,EAA2B,GAAmBC,EAAwB,IAAgBC,EAAuB,IAA+B,CACtL,IAAMG,EAAiC,CAAC,EACpCF,EAAYF,EAEhB,GACEE,GAAaD,EACbG,EAAOF,EAAU,SAAS,CAAC,EAAI,QACxBA,EAAYH,GAErB,OAAOK,CACT,CCnCO,SAASE,EAAqBC,EAAoBC,EAAsBC,EAAS,EAAGC,EAA4B,IAAuC,CAC5J,IAAMC,EAAe,CAAC,EAEhB,CAAC,OAAAC,CAAM,EAAIL,EAKjB,QAAS,EAAIE,EAAQ,EAAIG,EAAQ,GAAK,EAChCL,EAAK,CAAC,EAAIC,IACZG,EAAM,KAAK,CAAC,EAKZ,GAAKD,GAIT,MAAO,CACL,MAAAC,EACA,UAAAH,CACF,CACF,CAOA,eAAsBK,EAAUC,EAAuD,CACrF,IAAIC,EAAoB,CAAC,EACrBC,EAAiB,EAErB,aAAMC,EAAyB,MAAMT,GAAa,CAChD,GAAM,CAAC,MAAAG,CAAK,EAAIL,EAAqBQ,EAAaN,CAAS,EAK3D,OAAIG,EAAM,OAAgB,GACjB,IAGTI,EAAaJ,EACbK,EAAiBR,EAEV,GACT,CAAC,EAEM,CACL,MAAOO,EACP,UAAWC,CACb,CACF,CAQO,SAASE,EAAiBC,EAAgE,CAC/F,IAAMC,EAAUD,EAAQ,mBAAmB,EAC3CC,EAAQ,KAAO,UACfA,EAAQ,UAAU,MAAe,IACjCA,EAAQ,EAAE,MAAe,EAEzB,IAAMC,EAAWF,EAAQ,mBAAmB,EAC5C,OAAAE,EAAS,KAAO,WAChBA,EAAS,UAAU,MAAe,IAClCA,EAAS,EAAE,MAAe,EAEnB,CACL,QAAAD,EACA,SAAAC,CACF,CACF,CAuCA,eAAsBC,EAAWf,EAAkBgB,EAAiD,CAClG,IAAMC,EAAkB,GAKpBC,EAAW,GACXC,EAAwB,GAe5B,GAbA,MAAMT,EAAyB,MAAOT,GAChCiB,EACK,IAGLlB,EAAKC,CAAS,EAAE,OAASgB,IAC3BC,EAAW,GACXC,EAAiBlB,GAGZ,GACR,EAEGiB,GAAYC,EAAgB,CAC9B,IAAMC,EAAYC,EAAkBrB,EAAKmB,CAAc,CAAC,EAClDG,EAASC,EAAaP,EAAiBI,CAAS,EAQtD,MALqC,CACnC,IAHiBI,EAAiBF,CAAM,EAIxC,UAAWH,CACb,CAGF,CAEA,MAAO,CACL,IAAK,CAAC,EACN,UAAWA,CACb,CACF,CAQO,SAASK,EAAiBC,EAAqBpB,EAAS,EAAY,CACzE,OAAOoB,EAAW,KAAK,CAACC,EAAGC,IAAOA,EAAE,MAAQD,EAAE,KAAM,EAAE,OAAO,EAAGrB,CAAM,CACxE,CAsBO,SAASuB,EAAkBC,EAA0B,CAC1D,IAAMC,EAAwB,CAAC,EAE/B,QAASC,EAAI,EAAGA,EAAIF,EAAM,OAAQE,IAChC,QAASC,EAAI,EAAGA,EAAI,GAAIA,IAAK,CAC3B,IAAMC,EAAOJ,EAAME,CAAC,EACdG,EAAYH,EAAIC,EAChBG,EAAWN,EAAMK,CAAS,EAAID,EAiBpC,GAAI,CAZkBH,EAAU,KAAMM,GAChCA,EAAc,WAAaD,GAC7BC,EAAc,OAAS,EAChBA,EAAc,OAGhB,EACR,EAKmB,CAClB,IAAMC,EAAiB,CACrB,SAAAF,EACA,MAAO,CACT,EACAL,EAAU,KAAKO,CAAI,CACrB,CACF,CAGF,OAAOP,CACT,CAQO,SAASQ,EAAaC,EAAyBC,EAAqC,CACzF,IAAMC,EAAuB,CAAC,EAE9B,QAAWL,KAAiBI,EAAgB,CAI1C,GAAIJ,EAAc,WAAa,EAC7B,SAGFA,EAAc,SAAW,KAAK,IAAIA,EAAc,QAAQ,EAKxD,IAAIM,EAAoB,IAAMN,EAAc,SAAWG,GAKvD,KAAOG,EAAmB,IACxBA,GAAoB,EAGtB,KAAOA,EAAmB,KACxBA,GAAoB,EAuBtB,GAjBAA,EAAmB,KAAK,MAAMA,CAAgB,EAiB1C,CAZwBD,EAAY,KAAME,GACxCA,EAAW,QAAUD,GACvBC,EAAW,OAASP,EAAc,MAC3BO,EAAW,OAGb,EACR,EAKgB,CACf,IAAMC,EAAe,CACnB,MAAOF,EACP,MAAON,EAAc,MACrB,WAAY,CACd,EAEAK,EAAY,KAAKG,CAAK,CACxB,CACF,CAEA,OAAOH,CACT,CAQA,eAAsBI,EAAkBC,EAAuC,CAC7E,IAAMC,EAAcD,EAAO,eAAe,CAAC,EAErC,CAAC,MAAAjB,CAAK,EAAI,MAAMmB,EAAUD,CAAW,EACrCjB,EAAYF,EAAkBC,CAAK,EACnCoB,EAASX,EAAaQ,EAAO,WAAYhB,CAAS,EAGxD,OAFsBoB,EAAiBD,EAAQF,EAAY,MAAM,CAGnE,CCrTA,IAAMI,EAAe,CACnB,kBAAmB,IAAa,GAChC,WAAY,IAAMC,EAAwB,EAC1C,eAAgB,IAAMC,EAA4B,EAClD,YAAa,IAAM,EACnB,oBAAqB,IAAM,CAC7B,EAKaC,EAAN,KAA0B,CAoC/B,aAAc,CAhCd,aAAsC,CACpC,mBAAoB,GACpB,kBAAmB,IACnB,kBAAmB,IACnB,MAAO,EACT,EAKA,uBAA+BH,EAAa,kBAAkB,EAI9D,gBAAyBA,EAAa,WAAW,EAIjD,oBAAiCA,EAAa,eAAe,EAI7D,iBAAsBA,EAAa,YAAY,EAC/C,yBAA8BA,EAAa,oBAAoB,EAI/D,wCAAqC,EAMnC,KAAK,qBAAqB,CAC5B,CAOA,sBAAsBI,EAAiD,CACrE,OAAO,OAAO,KAAK,QAASA,CAAU,EACtC,KAAK,qBAAqB,CAC5B,CAMA,sBAAuB,CACrB,KAAK,mCAAqC,KAAK,QAAQ,kBAAoB,GAC7E,CAMA,OAAc,CACZ,KAAK,kBAAoBJ,EAAa,kBAAkB,EACxD,KAAK,WAAaA,EAAa,WAAW,EAC1C,KAAK,eAAiBA,EAAa,eAAe,EAClD,KAAK,YAAcA,EAAa,YAAY,EAC5C,KAAK,oBAAsBA,EAAa,oBAAoB,CAC9D,CAOA,MAAM,gBAAgBK,EAAwC,CAC5D,KAAK,kBAAoB,OAAO,WAAWA,EAAa,QAAQ,CAAC,CAAC,EAElE,MAAMC,EAAyB,MAAMC,IAC/BA,EAAYF,GAAgB,KAAK,WAAWE,CAAS,IAAM,SAC7D,OAAO,KAAK,WAAWA,CAAS,EAChC,OAAO,KAAK,eAAeA,CAAS,GAG/B,GACR,CACH,CAUA,MAAM,cAAcC,EAA2BC,EAAyBC,EAAoBC,EAAkE,CACxJ,KAAK,QAAQ,OACfA,EAAY,CAAC,QAAS,gBAAiB,KAAMH,CAAW,CAAC,EAO3D,KAAK,qBAAuBE,EAK5B,IAAME,EAAkBF,EAAa,KAAK,YAKpCG,EAAkBD,EAAkBF,EAK1C,MAAM,KAAK,UAAUF,EAAaE,EAAYG,EAAiBD,EAAiBD,CAAW,EAK3F,KAAK,cAEL,IAAMG,EAAwB,MAAMC,EAAW,KAAK,WAAYN,CAAe,EACzE,CAAC,UAAAF,CAAS,EAAIO,EACpBH,EAAY,CAAC,QAAS,MAAO,OAAAG,CAAM,CAAC,EAKhC,KAAK,kBAAoBP,IAC3BI,EAAY,CAAC,QAAS,aAAc,OAAAG,CAAM,CAAC,EAC3C,MAAM,KAAK,gBAAgBP,CAAS,GAMlC,KAAK,QAAQ,oBAAsB,KAAK,oBAAsBE,EAAkB,KAAK,qCACvF,KAAK,MAAM,EACXE,EAAY,CAAC,QAAS,kBAAkB,CAAC,EAE7C,CAWA,MAAM,UAAUH,EAA2BE,EAAoBG,EAAyBD,EAAyBD,EAAkE,CACjL,MAAML,EAAyB,MAAMC,GAAa,CAChD,GAAI,KAAK,eAAeA,CAAS,GAAKK,EACpC,MAAO,GAMT,IAAMI,EAAoB,KAAK,eAAeT,CAAS,EAAIG,EAErD,CAAC,MAAAO,EAAO,UAAWC,CAAW,EAAIC,EAAqBX,EAAaD,EAAWS,CAAiB,EAKtG,GAAIC,EAAM,SAAW,EACnB,MAAO,GAGT,QAAWG,KAAqBH,EAAO,CACrC,IAAMI,EAAQR,EAAkBO,EAKhC,KAAK,eAAeF,CAAW,EAAIG,EAAQ,KAAK,QAAQ,kBAKxD,KAAK,WAAWH,CAAW,EAAE,KAAKG,CAAK,EAEnC,KAAK,QAAQ,OACfV,EAAY,CACV,QAAS,aACT,KAAM,CACJ,UAAWO,EACX,MAAAG,CACF,CACF,CAAC,CAEL,CAEA,MAAO,EACT,EAAG,KAAK,iBAAiB,CAC3B,CACF,EC9NA,eAAsBC,EAA2BC,EAAuD,CACtG,IAAMC,EAAgB,MAAMC,EAAsBF,EAAcG,CAAwB,EAExF,aAAMH,EAAa,OAAO,EAEnBC,CACT,CASA,eAAeC,EAAsBF,EAA4BI,EAAkD,CACjH,IAAMC,EAAO,IAAI,KAAK,CAACC,CAA2B,EAAG,CAAC,KAAM,wBAAwB,CAAC,EAE/EC,EAAY,IAAI,gBAAgBF,CAAI,EAE1C,aAAML,EAAa,aAAa,UAAUO,CAAS,EAE1B,IAAI,iBAAiBP,EAAcI,CAAa,CAG3E",
  "names": ["realtimeBpmProcessorName", "generated_processor_default", "descendingOverThresholds", "onThreshold", "minValidThreshold", "startThreshold", "thresholdStep", "threshold", "generateValidPeaksModel", "object", "generateNextIndexPeaksModel", "findPeaksAtThreshold", "data", "threshold", "offset", "skipForwardIndexes", "peaks", "length", "findPeaks", "channelData", "validPeaks", "validThreshold", "descendingOverThresholds", "getBiquadFilters", "context", "lowpass", "highpass", "computeBpm", "audioSampleRate", "minPeaks", "hasPeaks", "foundThreshold", "intervals", "identifyIntervals", "tempos", "groupByTempo", "getTopCandidates", "candidates", "a", "b", "identifyIntervals", "peaks", "intervals", "n", "i", "peak", "peakIndex", "interval", "intervalCount", "item", "groupByTempo", "audioSampleRate", "intervalCounts", "tempoCounts", "theoreticalTempo", "tempoCount", "tempo", "analyzeFullBuffer", "buffer", "channelData", "findPeaks", "tempos", "getTopCandidates", "initialValue", "generateValidPeaksModel", "generateNextIndexPeaksModel", "RealTimeBpmAnalyzer", "parameters", "minThreshold", "descendingOverThresholds", "threshold", "channelData", "audioSampleRate", "bufferSize", "postMessage", "currentMaxIndex", "currentMinIndex", "result", "computeBpm", "offsetForNextPeak", "peaks", "atThreshold", "findPeaksAtThreshold", "relativeChunkPeak", "index", "createRealTimeBpmProcessor", "audioContext", "processorNode", "setupAudioWorkletNode", "realtimeBpmProcessorName", "processorName", "blob", "generated_processor_default", "objectUrl"]
}
