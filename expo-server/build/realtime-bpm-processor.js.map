{
  "version": 3,
  "sources": ["../src/consts.ts", "../src/utils.ts", "../src/analyzer.ts", "../src/realtime-bpm-analyzer.ts", "../processor/realtime-bpm-processor.ts"],
  "sourcesContent": ["export const realtimeBpmProcessorName = 'realtime-bpm-processor';\nexport const startThreshold = 0.95;\nexport const minValidThreshold = 0.2;\nexport const minPeaks = 15;\nexport const thresholdStep = 0.05;\nexport const skipForwardIndexes = 10000;\nexport const offlineLowPassFrequencyValue = 150;\nexport const offlineLowPassQualityValue = 1;\nexport const offlineHighPassFrequencyValue = 100;\nexport const offlineHighPassQualityValue = 1;\n\n", "import * as consts from './consts';\nimport type {Peaks, ValidPeaks, NextIndexPeaks, OnThresholdFunction, AggregateData} from './types';\n\n/**\n * Loop between .9 and minValidThreshold at .2 by default, passing the threshold to the function\n * @param {OnThresholdFunction} onThreshold Function for each iteration, you must return a boolean, true will exit the loop process\n * @param {number} minValidThreshold minValidThreshold usualy 0.2\n * @param {number} startThreshold startThreshold usualy 0.9\n * @param {number} thresholdStep thresholdStep usuably 0.05\n * @return {Promise<void>}\n */\nexport async function descendingOverThresholds(onThreshold: OnThresholdFunction, minValidThreshold = consts.minValidThreshold, startThreshold = consts.startThreshold, thresholdStep = consts.thresholdStep): Promise<void> {\n  let threshold = startThreshold;\n\n  do {\n    threshold -= thresholdStep;\n    const shouldExit = await onThreshold(threshold);\n    if (shouldExit) {\n      break;\n    }\n  } while (threshold > minValidThreshold);\n}\n\n/**\n * Generate an object with keys as thresholds and will containes validPeaks\n * @param {number} minValidThreshold minValidThreshold usualy 0.2\n * @param {number} startThreshold startThreshold usualy 0.9\n * @param {number} thresholdStep thresholdStep usuably 0.05\n * @return {ValidPeaks} Collection of validPeaks by thresholds\n */\nexport function generateValidPeaksModel(minValidThreshold = consts.minValidThreshold, startThreshold = consts.startThreshold, thresholdStep = consts.thresholdStep): ValidPeaks {\n  const object: Record<string, Peaks> = {};\n  let threshold = startThreshold;\n\n  do {\n    threshold -= thresholdStep;\n    object[threshold.toString()] = [];\n  } while (threshold > minValidThreshold);\n\n  return object;\n}\n\n/**\n * Generate an object with keys as thresholds and will containes NextIndexPeaks\n * @return {NextIndexPeaks} Collection of NextIndexPeaks by thresholds\n */\nexport function generateNextIndexPeaksModel(minValidThreshold = consts.minValidThreshold, startThreshold = consts.startThreshold, thresholdStep = consts.thresholdStep): NextIndexPeaks {\n  const object: Record<string, number> = {};\n  let threshold = startThreshold;\n\n  do {\n    threshold -= thresholdStep;\n    object[threshold.toString()] = 0;\n  } while (threshold > minValidThreshold);\n\n  return object;\n}\n\nexport function chunckAggregator(): (pcmData: Float32Array) => AggregateData {\n  const bufferSize = 4096;\n\n  /**\n   * Track the current buffer fill level\n   */\n  let _bytesWritten = 0;\n\n  /**\n   * Create a buffer of fixed size\n   */\n  let buffer: Float32Array = new Float32Array(0);\n\n  function initBuffer(): void {\n    _bytesWritten = 0;\n    buffer = new Float32Array(0);\n  }\n\n  function isBufferFull(): boolean {\n    return _bytesWritten === bufferSize;\n  }\n\n  function flush(): void {\n    initBuffer();\n  }\n\n  return function (pcmData: Float32Array): AggregateData {\n    if (isBufferFull()) {\n      flush();\n    }\n\n    const newBuffer = new Float32Array(buffer.length + pcmData.length);\n    newBuffer.set(buffer, 0);\n    newBuffer.set(pcmData, buffer.length);\n    buffer = newBuffer;\n    _bytesWritten += pcmData.length;\n\n    return {\n      isBufferFull: isBufferFull(),\n      buffer,\n      bufferSize,\n    };\n  };\n}\n", "import {descendingOverThresholds} from './utils';\nimport type {\n  Peaks,\n  ValidPeaks,\n  PeaksAndThreshold,\n  BpmCandidates,\n  Interval,\n  Tempo,\n  Threshold,\n  NormalizedFilters,\n} from './types';\nimport * as consts from './consts';\n\n/**\n * Find peaks when the signal if greater than the threshold, then move 10_000 indexes (represents ~0.23s) to ignore the descending phase of the parabol\n * @param {Float32Array} data Buffer channel data\n * @param {number} threshold Threshold for qualifying as a peak\n * @param {number} offset Position where we start to loop\n * @param {number} skipForwardIndexes Numbers of index to skip when a peak is detected\n * @return {PeaksAndThreshold} Peaks found that are greater than the threshold\n */\nexport function findPeaksAtThreshold(data: Float32Array, threshold: Threshold, offset = 0, skipForwardIndexes = consts.skipForwardIndexes): PeaksAndThreshold {\n  const peaks: Peaks = [];\n\n  const {length} = data;\n\n  /**\n   * Identify peaks that are greater than the threshold, adding them to the collection\n   */\n  for (let i = offset; i < length; i += 1) {\n    if (data[i] > threshold) {\n      peaks.push(i);\n\n      /**\n       * Skip forward ~0.25s to pass this peak\n       */\n      i += skipForwardIndexes;\n    }\n  }\n\n  return {\n    peaks,\n    threshold,\n  };\n}\n\n/**\n * Find the minimum amount of peaks from top to bottom threshold, it's necessary to analyze at least 10seconds at 90bpm\n * @param {Float32Array} channelData Channel data\n * @returns {Promise<PeaksAndThreshold>} Suffisent amount of peaks in order to continue further the process\n */\nexport async function findPeaks(channelData: Float32Array): Promise<PeaksAndThreshold> {\n  let validPeaks: Peaks = [];\n  let validThreshold = 0;\n\n  await descendingOverThresholds(async threshold => {\n    const {peaks} = findPeaksAtThreshold(channelData, threshold);\n\n    /**\n     * Loop over peaks\n     */\n    if (peaks.length < consts.minPeaks) {\n      return false;\n    }\n\n    validPeaks = peaks;\n    validThreshold = threshold;\n\n    return true;\n  });\n\n  return {\n    peaks: validPeaks,\n    threshold: validThreshold,\n  };\n}\n\n/**\n * Helpfull function to create standard and shared lowpass and highpass filters\n * Important Note: The original library wasn't using properly the lowpass filter and it was not applied at all. This method should not be used unitl more research and documented tests will be acheived.\n * @param {AudioContext | OfflineAudioContext} context AudioContext instance\n * @returns {NormalizedFilters} Normalized biquad filters\n */\nexport function getBiquadFilters(context: AudioContext | OfflineAudioContext): NormalizedFilters {\n  const lowpass = context.createBiquadFilter();\n  lowpass.type = 'lowpass';\n  lowpass.frequency.value = consts.offlineLowPassFrequencyValue;\n  lowpass.Q.value = consts.offlineLowPassQualityValue;\n\n  const highpass = context.createBiquadFilter();\n  highpass.type = 'highpass';\n  highpass.frequency.value = consts.offlineHighPassFrequencyValue;\n  highpass.Q.value = consts.offlineHighPassQualityValue;\n\n  return {\n    lowpass,\n    highpass,\n  };\n}\n\n/**\n * Apply to the source a biquad lowpass filter\n * @param {AudioBuffer} buffer Audio buffer\n * @returns {AudioBufferSourceNode}\n */\n// export async function getOfflineLowPassSource(buffer: AudioBuffer): Promise<AudioBuffer> {\n//   const {length, numberOfChannels, sampleRate} = buffer;\n//   const context = new OfflineAudioContext(numberOfChannels, length, sampleRate);\n\n//   /**\n//    * Create buffer source\n//    */\n//   const source = context.createBufferSource();\n//   source.buffer = buffer;\n\n//   const {lowpass, highpass} = getBiquadFilters(context);\n\n//   /**\n//    * Pipe the song into the filter, and the filter into the offline context\n//    */\n//   source.connect(lowpass);\n//   source.connect(highpass);\n//   lowpass.connect(highpass);\n//   highpass.connect(context.destination);\n\n//   source.start(0);\n\n//   const audioBuffer = await context.startRendering();\n\n//   return audioBuffer;\n// }\n\n/**\n * Return the computed bpm from data\n * @param {Record<string, number[]>} data Contain valid peaks\n * @param {number} audioSampleRate Audio sample rate\n */\nexport async function computeBpm(data: ValidPeaks, audioSampleRate: number): Promise<BpmCandidates> {\n  const minPeaks = consts.minPeaks;\n\n  /**\n   * Flag to fix Object.keys looping\n   */\n  let hasPeaks = false;\n  let foundThreshold = consts.minValidThreshold;\n\n  await descendingOverThresholds(async (threshold: Threshold) => {\n    if (hasPeaks) {\n      return true;\n    }\n\n    if (data[threshold].length > minPeaks) {\n      hasPeaks = true;\n      foundThreshold = threshold;\n    }\n\n    return false;\n  });\n\n  if (hasPeaks && foundThreshold) {\n    const intervals = identifyIntervals(data[foundThreshold]);\n    const tempos = groupByTempo(audioSampleRate, intervals);\n    const candidates = getTopCandidates(tempos);\n\n    const bpmCandidates: BpmCandidates = {\n      bpm: candidates,\n      threshold: foundThreshold,\n    };\n\n    return bpmCandidates;\n  }\n\n  return {\n    bpm: [],\n    threshold: foundThreshold,\n  };\n}\n\n/**\n * Sort results by count and return top candidate\n * @param {Tempo[]} candidates (BPMs) with count\n * @param {number} length Amount of returned candidates (default: 5)\n * @return {Tempo[]} Returns the 5 top candidates with highest counts\n */\nexport function getTopCandidates(candidates: Tempo[], length = 5): Tempo[] {\n  return candidates.sort((a, b) => (b.count - a.count)).splice(0, length);\n}\n\n/**\n * Gets the top candidate from the array\n * @param {Tempo[]} candidates - (BPMs) with counts.\n * @returns {number} - Returns the top candidate with the highest count.\n */\nexport function getTopCandidate(candidates: Tempo[]): number {\n  if (candidates.length === 0) {\n    throw new Error('Could not find enough samples for a reliable detection.');\n  }\n\n  const [first] = candidates.sort((a, b) => (b.count - a.count));\n\n  return first.tempo;\n}\n\n/**\n * Identify intervals between bass peaks\n * @param {array} peaks Array of qualified bass peaks\n * @return {array} Return a collection of intervals between peaks\n */\nexport function identifyIntervals(peaks: Peaks): Interval[] {\n  const intervals: Interval[] = [];\n\n  for (let n = 0; n < peaks.length; n++) {\n    for (let i = 0; i < 10; i++) {\n      const peak = peaks[n];\n      const peakIndex = n + i;\n      const interval = peaks[peakIndex] - peak;\n\n      /**\n       * Try and find a matching interval and increase it's count\n       */\n      const foundInterval = intervals.some((intervalCount: Interval) => {\n        if (intervalCount.interval === interval) {\n          intervalCount.count += 1;\n          return intervalCount.count;\n        }\n\n        return false;\n      });\n\n      /**\n       * Add the interval to the collection if it's unique\n       */\n      if (!foundInterval) {\n        const item: Interval = {\n          interval,\n          count: 1,\n        };\n        intervals.push(item);\n      }\n    }\n  }\n\n  return intervals;\n}\n\n/**\n * Figure out best possible tempo candidates\n * @param  {number} audioSampleRate Audio sample rate\n * @param  {Interval[]} intervalCounts List of identified intervals\n * @return {Tempo[]} Intervals grouped with similar values\n */\nexport function groupByTempo(audioSampleRate: number, intervalCounts: Interval[]): Tempo[] {\n  const tempoCounts: Tempo[] = [];\n\n  for (const intervalCount of intervalCounts) {\n    /**\n     * Skip if interval is equal 0\n     */\n    if (intervalCount.interval === 0) {\n      continue;\n    }\n\n    intervalCount.interval = Math.abs(intervalCount.interval);\n\n    /**\n     * Convert an interval to tempo\n     */\n    let theoreticalTempo = (60 / (intervalCount.interval / audioSampleRate));\n\n    /**\n     * Adjust the tempo to fit within the 90-180 BPM range\n     */\n    while (theoreticalTempo < 90) {\n      theoreticalTempo *= 2;\n    }\n\n    while (theoreticalTempo > 180) {\n      theoreticalTempo /= 2;\n    }\n\n    /**\n     * Round to legible integer\n     */\n    theoreticalTempo = Math.round(theoreticalTempo);\n\n    /**\n     * See if another interval resolved to the same tempo\n     */\n    const foundTempo: boolean = tempoCounts.some((tempoCount: Tempo) => {\n      if (tempoCount.tempo === theoreticalTempo) {\n        tempoCount.count += intervalCount.count;\n        return tempoCount.count;\n      }\n\n      return false;\n    });\n\n    /**\n     * Add a unique tempo to the collection\n     */\n    if (!foundTempo) {\n      const tempo: Tempo = {\n        tempo: theoreticalTempo,\n        count: intervalCount.count,\n        confidence: 0,\n      };\n\n      tempoCounts.push(tempo);\n    }\n  }\n\n  return tempoCounts;\n}\n\n/**\n * Function to detect the BPM from an AudioBuffer (which can be a whole file)\n * It is the fastest way to detect the BPM\n * @param {AudioBuffer} buffer AudioBuffer\n * @returns {Promise<Tempo[]>} Returns the 5 bests candidates\n */\nexport async function analyzeFullBuffer(buffer: AudioBuffer): Promise<Tempo[]> {\n  const channelData = buffer.getChannelData(0);\n\n  const {peaks} = await findPeaks(channelData);\n  const intervals = identifyIntervals(peaks);\n  const tempos = groupByTempo(buffer.sampleRate, intervals);\n  const topCandidates = getTopCandidates(tempos, channelData.length);\n\n  return topCandidates;\n}\n", "import {findPeaksAtThreshold, computeBpm} from './analyzer';\nimport type {\n  RealTimeBpmAnalyzerOptions,\n  RealTimeBpmAnalyzerParameters,\n  ValidPeaks,\n  NextIndexPeaks,\n  BpmCandidates,\n  Threshold,\n  PostMessageEventData,\n} from './types';\nimport {\n  generateValidPeaksModel,\n  generateNextIndexPeaksModel,\n  descendingOverThresholds,\n} from './utils';\nimport * as consts from './consts';\n\n/**\n * Initial value of key parameters of the analyzer\n */\nconst initialValue = {\n  minValidThreshold: () => consts.minValidThreshold,\n  validPeaks: () => generateValidPeaksModel(),\n  nextIndexPeaks: () => generateNextIndexPeaksModel(),\n  skipIndexes: () => 1,\n  effectiveBufferTime: () => 0,\n};\n\n/**\n * @class RealTimeBpmAnalyzer\n **/\nexport class RealTimeBpmAnalyzer {\n  /**\n   * Default configuration\n   */\n  options: RealTimeBpmAnalyzerOptions = {\n    continuousAnalysis: false,\n    stabilizationTime: 20000,\n    muteTimeInIndexes: 10000,\n    debug: false,\n  };\n\n  /**\n   * Minimum valid threshold, below this level result would be irrelevant.\n   */\n  minValidThreshold: Threshold = initialValue.minValidThreshold();\n  /**\n   * Contain all valid peaks\n   */\n  validPeaks: ValidPeaks = initialValue.validPeaks();\n  /**\n   * Next index (+10000 ...) to take care about peaks\n   */\n  nextIndexPeaks: NextIndexPeaks = initialValue.nextIndexPeaks();\n  /**\n   * Number / Position of chunks\n   */\n  skipIndexes: number = initialValue.skipIndexes();\n  effectiveBufferTime: number = initialValue.effectiveBufferTime();\n  /**\n   * Computed values\n   */\n  computedStabilizationTimeInSeconds = 0;\n\n  /**\n   * @constructor\n   */\n  constructor() {\n    this.updateComputedValues();\n  }\n\n  /**\n   * Method to apply a configuration on the fly\n   * @param {RealTimeBpmAnalyzerParameters} parameters Object containing optional parameters\n   * @returns {void}\n   */\n  setAsyncConfiguration(parameters: RealTimeBpmAnalyzerParameters): void {\n    Object.assign(this.options, parameters);\n    this.updateComputedValues();\n  }\n\n  /**\n   * Update the computed values\n   * @returns {void}\n   */\n  updateComputedValues() {\n    this.computedStabilizationTimeInSeconds = this.options.stabilizationTime / 1000;\n  }\n\n  /**\n   * Reset BPM computation properties to get a fresh start\n   * @returns {void}\n   */\n  reset(): void {\n    this.minValidThreshold = initialValue.minValidThreshold();\n    this.validPeaks = initialValue.validPeaks();\n    this.nextIndexPeaks = initialValue.nextIndexPeaks();\n    this.skipIndexes = initialValue.skipIndexes();\n    this.effectiveBufferTime = initialValue.effectiveBufferTime();\n  }\n\n  /**\n   * Remve all validPeaks between the minThreshold pass in param to optimize the weight of datas\n   * @param {Threshold} minThreshold Value between 0.9 and 0.2\n   * @returns {void}\n   */\n  async clearValidPeaks(minThreshold: Threshold): Promise<void> {\n    this.minValidThreshold = Number.parseFloat(minThreshold.toFixed(2));\n\n    await descendingOverThresholds(async threshold => {\n      if (threshold < minThreshold && this.validPeaks[threshold] !== undefined) {\n        delete this.validPeaks[threshold]; // eslint-disable-line @typescript-eslint/no-dynamic-delete\n        delete this.nextIndexPeaks[threshold]; // eslint-disable-line @typescript-eslint/no-dynamic-delete\n      }\n\n      return false;\n    });\n  }\n\n  /**\n   * Attach this function to an audioprocess event on a audio/video node to compute BPM / Tempo in realtime\n   * @param {Float32Array} channelData Channel data\n   * @param {number} audioSampleRate Audio sample rate (44100)\n   * @param {number} bufferSize Buffer size (4096)\n   * @param {(data: PostMessageEventData) => void} postMessage Function to post a message to the processor node\n   * @returns {Promise<void>}\n   */\n  async analyzeChunck(channelData: Float32Array, audioSampleRate: number, bufferSize: number, postMessage: (data: PostMessageEventData) => void): Promise<void> {\n    if (this.options.debug) {\n      postMessage({message: 'ANALYZE_CHUNK', data: channelData});\n    }\n\n    /**\n     * We are summing up the size of each analyzed chunks in order to compute later if we reached the stabilizationTime\n     * Ex: effectiveBufferTime / audioSampleRate = timeInSeconds (1000000/44100=22s)\n     */\n    this.effectiveBufferTime += bufferSize;\n\n    /**\n     * Compute the maximum index with all previous chunks\n     */\n    const currentMaxIndex = bufferSize * this.skipIndexes;\n\n    /**\n     * Compute the minimum index with all previous chunks\n     */\n    const currentMinIndex = currentMaxIndex - bufferSize;\n\n    /**\n     * Mutate nextIndexPeaks and validPeaks if possible\n     */\n    await this.findPeaks(channelData, bufferSize, currentMinIndex, currentMaxIndex, postMessage);\n\n    /**\n     * Increment chunk\n     */\n    this.skipIndexes++;\n\n    const result: BpmCandidates = await computeBpm(this.validPeaks, audioSampleRate);\n    const {threshold} = result;\n    postMessage({message: 'BPM', result});\n\n    /**\n     * If the results found have a \"high\" threshold, the BPM is considered stable/strong\n     */\n    if (this.minValidThreshold < threshold) {\n      postMessage({message: 'BPM_STABLE', result});\n      await this.clearValidPeaks(threshold);\n    }\n\n    /**\n     * After x time, we reinit the analyzer\n     */\n    if (this.options.continuousAnalysis && this.effectiveBufferTime / audioSampleRate > this.computedStabilizationTimeInSeconds) {\n      this.reset();\n      postMessage({message: 'ANALYZER_RESETED'});\n    }\n  }\n\n  /**\n   * Find the best threshold with enought peaks\n   * @param {Float32Array} channelData Channel data\n   * @param {number} bufferSize Buffer size\n   * @param {number} currentMinIndex Current minimum index\n   * @param {number} currentMaxIndex Current maximum index\n   * @param {(data: PostMessageEventData) => void} postMessage Function to post a message to the processor node\n   * @returns {void}\n   */\n  async findPeaks(channelData: Float32Array, bufferSize: number, currentMinIndex: number, currentMaxIndex: number, postMessage: (data: PostMessageEventData) => void): Promise<void> {\n    await descendingOverThresholds(async threshold => {\n      if (this.nextIndexPeaks[threshold] >= currentMaxIndex) {\n        return false;\n      }\n\n      /**\n       * Get the next index in the next chunk\n       */\n      const offsetForNextPeak = this.nextIndexPeaks[threshold] % bufferSize; // 0 - 4095\n\n      const {peaks, threshold: atThreshold} = findPeaksAtThreshold(channelData, threshold, offsetForNextPeak);\n\n      /**\n       * Loop over peaks\n       */\n      if (peaks.length === 0) {\n        return false;\n      }\n\n      for (const relativeChunkPeak of peaks) {\n        const index = currentMinIndex + relativeChunkPeak;\n\n        /**\n         * Add current Index + muteTimeInIndexes (10000/44100=0.22s)\n         */\n        this.nextIndexPeaks[atThreshold] = index + this.options.muteTimeInIndexes;\n\n        /**\n         * Store valid relativeChunkPeak Indexes\n         */\n        this.validPeaks[atThreshold].push(index);\n\n        if (this.options.debug) {\n          postMessage({\n            message: 'VALID_PEAK',\n            data: {\n              threshold: atThreshold,\n              index,\n            },\n          });\n        }\n      }\n\n      return false;\n    }, this.minValidThreshold);\n  }\n}\n", "import {realtimeBpmProcessorName} from '../src/consts';\nimport {chunckAggregator} from '../src/utils';\nimport {RealTimeBpmAnalyzer} from '../src/realtime-bpm-analyzer';\nimport type {AsyncConfigurationEvent, AggregateData} from '../src/types';\n\n/**\n * Those declaration are from the package @types/audioworklet. But it is not compatible with the lib 'dom'.\n */\n/* eslint-disable no-var, @typescript-eslint/prefer-function-type, @typescript-eslint/no-empty-interface, @typescript-eslint/consistent-type-definitions, @typescript-eslint/no-redeclare, @typescript-eslint/naming-convention */\ndeclare var sampleRate: number;\n\ninterface AudioWorkletProcessor {\n  readonly port: MessagePort;\n}\n\ndeclare var AudioWorkletProcessor: {\n  prototype: AudioWorkletProcessor;\n  new(): AudioWorkletProcessor;\n};\n\ninterface AudioWorkletProcessorImpl extends AudioWorkletProcessor {\n  process(inputs: Float32Array[][], outputs: Float32Array[][], parameters: Record<string, Float32Array>): boolean;\n}\n\ninterface WorkletGlobalScope {}\n\ndeclare var WorkletGlobalScope: {\n  prototype: WorkletGlobalScope;\n  new(): WorkletGlobalScope;\n};\n\ninterface AudioWorkletGlobalScope extends WorkletGlobalScope {\n  readonly currentFrame: number;\n  readonly currentTime: number;\n  readonly sampleRate: number;\n  registerProcessor(name: string, processorCtor: AudioWorkletProcessorConstructor): void;\n}\n\ndeclare var AudioWorkletGlobalScope: {\n  prototype: AudioWorkletGlobalScope;\n  new(): AudioWorkletGlobalScope;\n};\n\ninterface AudioWorkletProcessorConstructor {\n  new (options: any): AudioWorkletProcessorImpl;\n}\n\ndeclare function registerProcessor(name: string, processorCtor: AudioWorkletProcessorConstructor): void;\n/* eslint-enable no-var, @typescript-eslint/prefer-function-type, @typescript-eslint/no-empty-interface, @typescript-eslint/consistent-type-definitions, @typescript-eslint/no-redeclare, @typescript-eslint/naming-convention */\n\n/**\n * @class RealTimeBpmProcessor\n * @extends AudioWorkletProcessor\n **/\nexport class RealTimeBpmProcessor extends AudioWorkletProcessor {\n  aggregate: (pcmData: Float32Array) => AggregateData;\n  realTimeBpmAnalyzer: RealTimeBpmAnalyzer = new RealTimeBpmAnalyzer();\n  stopped = false;\n\n  constructor() {\n    super();\n\n    this.aggregate = chunckAggregator();\n\n    this.port.addEventListener('message', this.onMessage.bind(this));\n    this.port.start();\n  }\n\n  /**\n   * Handle message event\n   * @param {object} event Contain event data from main process\n   * @returns {void}\n   */\n  onMessage(event: AsyncConfigurationEvent): void {\n    // Handle custom event ASYNC_CONFIGURATION, to set configuration asynchronously\n    if (event.data.message === 'ASYNC_CONFIGURATION') {\n      console.log('[processor.onMessage] ASYNC_CONFIGURATION');\n      this.realTimeBpmAnalyzer.setAsyncConfiguration(event.data.parameters);\n    }\n\n    // Handle custom event RESET\n    if (event.data.message === 'RESET') {\n      console.log('[processor.onMessage] RESET');\n      this.aggregate = chunckAggregator();\n      this.stopped = false;\n      this.realTimeBpmAnalyzer.reset();\n    }\n\n    if (event.data.message === 'STOP') {\n      console.log('[processor.onMessage] STOP');\n      this.aggregate = chunckAggregator();\n      this.stopped = true;\n      this.realTimeBpmAnalyzer.reset();\n    }\n  }\n\n  /**\n   * Process function to handle chunks of data\n   * @param {Float32Array[][]} inputs Inputs (the data we need to process)\n   * @param {Float32Array[][]} _outputs Outputs (not useful for now)\n   * @param {Record<string, Float32Array>} _parameters Parameters\n   * @returns {boolean} Process ended successfully\n   */\n  process(inputs: Float32Array[][], _outputs: Float32Array[][], _parameters: Record<string, Float32Array>): boolean {\n    const currentChunk = inputs[0][0];\n\n    if (this.stopped) {\n      return true;\n    }\n\n    if (!currentChunk) {\n      return true;\n    }\n\n    const {isBufferFull, buffer, bufferSize} = this.aggregate(currentChunk);\n\n    if (isBufferFull) {\n      // The variable sampleRate is global ! thanks to the AudioWorkletProcessor\n      this.realTimeBpmAnalyzer.analyzeChunck(buffer, sampleRate, bufferSize, event => {\n        this.port.postMessage(event);\n      }).catch((error: unknown) => {\n        console.error(error);\n      });\n    }\n\n    return true;\n  }\n}\n\n/**\n * Mandatory Registration to use the processor\n */\nregisterProcessor(realtimeBpmProcessorName, RealTimeBpmProcessor);\n\nexport default {};\n"],
  "mappings": "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",
  "names": ["realtimeBpmProcessorName", "descendingOverThresholds", "onThreshold", "minValidThreshold", "startThreshold", "thresholdStep", "threshold", "generateValidPeaksModel", "object", "generateNextIndexPeaksModel", "chunckAggregator", "_bytesWritten", "buffer", "initBuffer", "isBufferFull", "flush", "pcmData", "newBuffer", "findPeaksAtThreshold", "data", "threshold", "offset", "skipForwardIndexes", "peaks", "length", "i", "computeBpm", "data", "audioSampleRate", "minPeaks", "hasPeaks", "foundThreshold", "descendingOverThresholds", "threshold", "intervals", "identifyIntervals", "tempos", "groupByTempo", "getTopCandidates", "candidates", "length", "a", "b", "identifyIntervals", "peaks", "intervals", "n", "i", "peak", "peakIndex", "interval", "intervalCount", "item", "groupByTempo", "audioSampleRate", "intervalCounts", "tempoCounts", "theoreticalTempo", "tempoCount", "tempo", "initialValue", "generateValidPeaksModel", "generateNextIndexPeaksModel", "RealTimeBpmAnalyzer", "parameters", "minThreshold", "descendingOverThresholds", "threshold", "channelData", "audioSampleRate", "bufferSize", "postMessage", "currentMaxIndex", "currentMinIndex", "result", "computeBpm", "offsetForNextPeak", "peaks", "atThreshold", "findPeaksAtThreshold", "relativeChunkPeak", "index", "RealTimeBpmProcessor", "RealTimeBpmAnalyzer", "chunckAggregator", "event", "inputs", "_outputs", "_parameters", "currentChunk", "isBufferFull", "buffer", "bufferSize", "error", "realtimeBpmProcessorName", "realtime_bpm_processor_default"]
}
